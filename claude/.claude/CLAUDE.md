# Global Rules

## Identity & Stealth
- Never add AI attribution, co-author tags, or "generated by" comments anywhere
- No AI-related markers in code, commits, PRs, comments, or documentation
- Write code as a senior human developer would - natural, consistent, professional
- Never mention AI assistance or Claude in any output

## Git Operations
- **No auto-commit/push**: Only when explicitly requested by user
- **One-time action**: "Commit and push" = do it ONCE, not recurring in session
- **Commit style**: Use conventional commits (`type(scope): message`), keep short
- **Atomic commits**: Group related changes by responsibility, one concern per commit
- **No merge commits**: Prefer rebase when cleaner

## Code Quality
- No redundant/obvious comments - code should be self-documenting
- No TODO comments without ticket/issue references
- No debug code, console.logs, or commented-out code in commits
- Follow existing project patterns exactly
- Prefer explicit over clever code
- Don't over-engineer or add unnecessary abstractions

## Workflow
- **Read before write**: Always read relevant files before suggesting changes
- **Plan complex tasks**: Use `ultrathink` for architectural decisions
- **Verify changes**: Run tests/lint after modifications when suite exists
- **Interrupt early**: Stop and ask if requirements are unclear

---

# Tech Stack Defaults

## TypeScript / Node.js
- Strict TypeScript (`strict: true`, `noImplicitAny`, `strictNullChecks`)
- **pnpm** for package management (not npm/yarn)
- **Bun** for scripts/runtime when applicable
- ES modules (`import`/`export`), no CommonJS
- `const` over `let`, never `var`
- Async/await over raw promises
- Zod for runtime validation

## React
- Functional components only, no class components
- Hooks for all state/effects
- Custom hooks for reusable logic (`use*` prefix)
- TanStack Query for data fetching
- Components: PascalCase, one per file
- Props interfaces: `ComponentNameProps`

## Python
- Python 3.11+ features allowed
- Type hints required for all functions
- `ruff` for linting, `black` for formatting
- Pydantic for data validation/serialization
- `pathlib` over `os.path`
- f-strings for formatting

## Go
- Standard Go project layout
- `go mod` for dependencies
- Error wrapping: `fmt.Errorf("context: %w", err)`
- Context propagation in all API functions
- Table-driven tests
- No global state

## Databases

### PostgreSQL / TimescaleDB
- Parameterized queries always (never string concat)
- Use migrations for schema changes
- TimescaleDB: hypertables for time-series data
- Proper indexing for query patterns
- Connection pooling in production

### MongoDB
- Schema validation where possible
- Proper indexing for query patterns
- Use aggregation pipelines for complex queries
- ObjectId for references

---

# Project Detection

When in a project, auto-detect and follow:
- `package.json` → Node.js/TypeScript project
- `pyproject.toml` / `requirements.txt` → Python project
- `go.mod` → Go project
- `docker-compose.yml` → Use containerized services
- `.env.example` → Required environment variables
